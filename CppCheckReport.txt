src/engine/storage/PersistentLeaf.h:25:22: performance:inconclusive: The member function 'pmem::storage::internal::PersistentLeaf::setKeySizeDirect' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
                void setKeySizeDirect(char *p, uint32_t v) {
                     ^
src/engine/storage/PersistentLeaf.h:29:22: performance:inconclusive: The member function 'pmem::storage::internal::PersistentLeaf::setValueSizeDirect' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
                void setValueSizeDirect(char *p, uint32_t v) {
                     ^
src/engine/storage/PersistentLeaf.h:82:26: performance:inconclusive: The member function 'pmem::storage::internal::PersistentLeaf::keySizeDirect' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
                uint32_t keySizeDirect(char *p) {
                         ^
src/engine/storage/PersistentLeaf.h:86:26: performance:inconclusive: The member function 'pmem::storage::internal::PersistentLeaf::valueSizeDirect' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
                uint32_t valueSizeDirect(char *p) {
                         ^
src/engine/storage/PersistentMemoryPool.h:61:17: performance:inconclusive: The member function 'pmem::storage::internal::PersistentMemoryPool::createOrFail' can be made a static function. Making a function static can bring a performance benefit since no 'this' instance is passed to the function. This change should not cause compiler errors but it does not necessarily make sense conceptually. Think about your design and the task of the function first - is it a function that must not access members of class instances? And maybe it is more appropriate to move this function to a unnamed namespace. [functionStatic]
                createOrFail(const char *path, const std::size_t size, const std::string &layout) {
                ^
src/engine/db/KeyValueSize.h:17:20: style:inconclusive: The member function 'pmem::storage::KeyValueSize::getKeySize' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
            size_t getKeySize();
                   ^
src/engine/db/KeyValueSize.cpp:7:30: note: Technically the member function 'pmem::storage::KeyValueSize::getKeySize' can be const.
        size_t KeyValueSize::getKeySize() {
                             ^
src/engine/db/KeyValueSize.h:17:20: note: Technically the member function 'pmem::storage::KeyValueSize::getKeySize' can be const.
            size_t getKeySize();
                   ^
src/engine/db/KeyValueSize.h:19:20: style:inconclusive: The member function 'pmem::storage::KeyValueSize::getValueSize' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
            size_t getValueSize();
                   ^
src/engine/db/KeyValueSize.cpp:11:30: note: Technically the member function 'pmem::storage::KeyValueSize::getValueSize' can be const.
        size_t KeyValueSize::getValueSize() {
                             ^
src/engine/db/KeyValueSize.h:19:20: note: Technically the member function 'pmem::storage::KeyValueSize::getValueSize' can be const.
            size_t getValueSize();
                   ^
src/engine/storage/PersistentMemoryPool.h:22:38: style:inconclusive: The member function 'pmem::storage::internal::PersistentMemoryPool::getPmpool' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
                pmem::obj::pool_base getPmpool();
                                     ^
src/engine/storage/PersistentMemoryPool.cpp:22:56: note: Technically the member function 'pmem::storage::internal::PersistentMemoryPool::getPmpool' can be const.
            pmem::obj::pool_base PersistentMemoryPool::getPmpool() {
                                                       ^
src/engine/storage/PersistentMemoryPool.h:22:38: note: Technically the member function 'pmem::storage::internal::PersistentMemoryPool::getPmpool' can be const.
                pmem::obj::pool_base getPmpool();
                                     ^
src/engine/storage/utils/LevelGenerator.h:13:21: style:inconclusive: The member function 'pmem::storage::internal::LevelGenerator::generate' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
                int generate();
                    ^
src/engine/storage/utils/LevelGenerator.cpp:13:33: note: Technically the member function 'pmem::storage::internal::LevelGenerator::generate' can be const.
            int LevelGenerator::generate() {
                                ^
src/engine/storage/utils/LevelGenerator.h:13:21: note: Technically the member function 'pmem::storage::internal::LevelGenerator::generate' can be const.
                int generate();
                    ^
src/engine/storage/utils/LevelGenerator.h:14:21: style:inconclusive: The member function 'pmem::storage::internal::LevelGenerator::getMaxLevel' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
                int getMaxLevel();
                    ^
src/engine/storage/utils/LevelGenerator.cpp:23:33: note: Technically the member function 'pmem::storage::internal::LevelGenerator::getMaxLevel' can be const.
            int LevelGenerator::getMaxLevel() {
                                ^
src/engine/storage/utils/LevelGenerator.h:14:21: note: Technically the member function 'pmem::storage::internal::LevelGenerator::getMaxLevel' can be const.
                int getMaxLevel();
                    ^
test/engine/benchmark/DbBenchmark.cpp:75:0: style: The function 'DBGet' is never used. [unusedFunction]

^
test/engine/benchmark/DbBenchmark.cpp:116:0: style: The function 'DBGetArguments' is never used. [unusedFunction]

^
test/engine/benchmark/DbBenchmark.cpp:128:0: style: The function 'DBScan' is never used. [unusedFunction]

^
test/engine/benchmark/DbBenchmark.cpp:178:0: style: The function 'DBScanArguments' is never used. [unusedFunction]

^
src/engine/storage/SkipListInternalNode.cpp:16:0: style: The function 'isLeaf' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files. Cppcheck can check the code without the include files found. But the results will probably be more accurate if all the include files are found. Please check your project's include directories and add all of them as include directories for Cppcheck. To see what files Cppcheck cannot find use --check-config. [missingIncludeSystem]

